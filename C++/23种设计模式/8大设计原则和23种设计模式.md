
- [如何解决复杂性](#如何解决复杂性)
- [8大设计原则](#8大设计原则)
- [23种设计模式](#23种设计模式)

**注意：重构。。。。**

## 如何解决复杂性
<a name="section-1"></a>
- 分解：分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题。
- 抽象：由于不能掌握全部的复杂对象，选择忽略它的本质细节而去处理泛化和理想化了的对象模型


##  8大设计原则
<a name="section-2" target="_self"></a>

1. 依赖倒置原则：高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象。抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象。
2. 开放封闭原则：对扩展开放，对修改封闭。类模块应该是可扩展的，但是不可修改。
3. 单一职责原则：一个类应该仅有一个引起它变化的原因，变化的方向隐含着类的责任。
4. 替换原则：子类必须能够替换它的基类，继承表达类型抽象。
5. 接口隔离原则：接口应该小而完备，不该强迫客户程序依赖它们不用的方法。
6. 优先使用对象组合而不是继承：类继承通常为“白箱复用”，对象组合通常为“黑箱复用”，继承通常会让子类和父类的耦合度增加，组合的方式只要求组件具备良好定义的接口，耦合度低。
7. 封装变化点：使用封装来创建对象之间的分界层，让设计者可以在分界线的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。
8. 针对接口编程，而不是针对实现编程：不将变量类型声明为某个特定的具体类，而是声明为某个接口。客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。减少系统中各部分的依赖关系，从而实现“高内聚、低耦合”的类型设计方案。

##  23种设计模式
<a name="section-3"></a>
1. 组件协作：
	- Template Method
	- Strategy
	- Observer/Event
2. 单一职责：
	- Decorator
	- Bridge
3. 对象创建
	- Factory Method
	- Abstract Factory
	- Prototype
	- Builder
4. 对象性能
	- Singleton
	- Flyweight
5. 接口隔离
	- Facade
	- Proxy
	- Mediator
	- Adapter
6. 状态变化
	- Memento
	- State
7. 数据结构类型
	- Composite
	- Iterator
	- Chain of Responsibility
8. 行为变化类型
	- Command
	- Visitor
9. 领域问题
	- Interpreter




