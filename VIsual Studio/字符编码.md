1. Unicode
2. GBK



### qt中字符串采用utf8编码，为什么中文开头没问题，英文开头却不行的解决
```txt
将编译器和编码方式都改为utf-8
```

##### 1、字符串中文开头正常
![[f24653bf22c0cd58564f46aa4070712.png]]
##### 2、字符串英文开头错误
![[1b06ec9cb506267b686e27c863e14ed.png]]

![[ec8c7c5f0902c1936fdb8f081a4bfca.png]]

##### 3、解决方案如下图所示
![[Pasted image 20241221181455.png]]
![[7c07876cb9cb96e902accff154f221a.png]]


### 下面我们用一个多字节表示一个字符的例子，来说明UTF-8为什么不受字节序大小端的影响。

### 例子：字符 "汉"

- 字符"汉"的Unicode码点是`U+6C49`。
- 在UTF-8编码中，"汉"被表示为三个字节：`0xE6 0xB1 0x89`。

#### 1. **UTF-8的多字节结构**

UTF-8是以字节为单位进行编码的，其多字节字符的编码规则如下：

- 第一个字节的高位标志其是多字节字符的起始字节（起始字节从`0xC0`以上开始）。
- 后续字节以`10xxxxxx`格式标志，表示它们是多字节字符的后续部分。

对于字符"汉"（`U+6C49`）：

- 它被编码为三个字节：
    - 起始字节：`0xE6`（指示这是一个3字节的UTF-8字符）。
    - 第二个字节：`0xB1`。
    - 第三个字节：`0x89`。

#### 2. **字节序对UTF-8的影响**

无论是在大端字节序还是小端字节序的系统中，"汉"的UTF-8编码总是按以下顺序存储和读取：`0xE6 0xB1 0x89`。因为UTF-8是逐字节存储的，字节的顺序与主机系统的字节序无关。

#### 3. **举例说明**

假设我们有一个文件存储了字符"汉"，其UTF-8编码是`0xE6 0xB1 0x89`，分别在大端和小端机器上存储和读取：

- **大端字节序系统**：
    
    - 存储：`0xE6 0xB1 0x89`
    - 读取：`0xE6 0xB1 0x89`
- **小端字节序系统**：
    
    - 存储：`0xE6 0xB1 0x89`
    - 读取：`0xE6 0xB1 0x89`

从上面可以看出，在两种系统中，UTF-8编码的字节顺序保持一致，完全不受字节序的影响。

### 4. **对比UTF-16和UTF-32**

如果用UTF-16或UTF-32编码字符"汉"，字节序就会产生影响：

- **UTF-16**：
    
    - "汉"的UTF-16编码是`0x6C49`（16位）。
    - 在大端系统中，存储为`0x6C 0x49`。
    - 在小端系统中，存储为`0x49 0x6C`。
- **UTF-32**：
    
    - "汉"的UTF-32编码是`0x00006C49`（32位）。
    - 在大端系统中，存储为`0x00 0x00 0x6C 0x49`。
    - 在小端系统中，存储为`0x49 0x6C 0x00 0x00`。

为了处理字节序问题，UTF-16和UTF-32通常会在文件的开头添加一个**字节顺序标记（BOM，Byte Order Mark）**，以指示字节序，这样接收端可以根据BOM来正确解析字节流。
